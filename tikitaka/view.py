import json
import logging
import os
import traceback
from django.http import HttpResponse
import requests
from news_processor.news.naver import NaverNews, News
from django.shortcuts import render
from django.template import loader

from tikitaka.context import BaseContext
from django.http import HttpResponseServerError
from django.views import View

_LOG = logging.getLogger(__name__)


class OperatorView(View):
    """A Django view which executes a specific operator.
    """

    # def __init__(self, **kwargs):
    #     """
    #     Args:
    #         operator_class: A BaseOperator class
    #     """
    #     super().__init__(**kwargs)

    # ----------------------------------------------------------------------------------------------
    def get(self, request, *args, **kwargs):
        """This processes request from clients.

        Args:
            request (HttpRequest): Request instance generated by django framework.
            *args: Arguments for various purpose.
            **kwargs: Keyword arguments for various purpose.

        Returns:
            HttpResponse: Response from updated context.

        """

        context = BaseContext(request)
        query = context.get_from_parameters('query')

        url = "https://openapi.naver.com/v1/search/news.json"

        querystring = {"query": query, "display": "30"}

        payload = ""
        headers = {
            'x-naver-client-id': os.environ["NAVER_CLIENT_ID"],
            'x-naver-client-secret': os.environ["NAVER_CLIENT_SECRET"]
        }

        response = requests.request("GET", url, data=payload, headers=headers, params=querystring)
        response_json = response.json()

        items = []
        for item in response_json.get('items', []):
            link = item.get('link', '')
            try:
                soup = NaverNews.get_soup(link)
                news = NaverNews(soup)
                item['key_sentences'] = news.key_sentences(3)
                items.append(item)
                # print('----------')
                # print(item['title'])
                # print(item['link'])
                # print(item['key_sentences'])
                # print(item)
            except:
                pass
        return render(request, 'index.html', {
            'items': items
        })

        # try:
        #     self._op.bake_context(context, request, **kwargs)
        #     # zipkin
        #     if self._op.span:
        #         self._op.span.start().annotate(zipkin.ANNOTATION_SERVER_RECV)
        #
        #     self._op.before_operate(context, **kwargs)
        #     self._op.operate(context, **kwargs)
        #     self._op.after_operate(context, **kwargs)
        #     return context.response_
        # except Exception as e:
        #     _LOG.error("Unexpected error while executing operator", exc_info=True)
        #
        #     content = '{{ "status": "Error", "errorCode": 999, "errorMessage": "{}" }}'.format(e)
        #     response = HttpResponseServerError(content=content, charset='UTF-8')
        #     response['content-type'] = "{}; charset={}".format('application/json', response.charset)
        #     if self._op.span:
        #         self._op.span.set_tag('error', content)
        #     return response
        # finally:
        #     # zipkin
        #     if self._op.span:
        #         self._op.span.set_tag('context.parameters', json.dumps(context.parameters))
        #         self._op.span.set_tag('context.data', json.dumps(context.data))
        #         self._op.span.annotate(zipkin.ANNOTATION_SERVER_SEND).finish()

    def post(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.get(request, *args, **kwargs)
